import {
  Injectable,
  Logger,
  BadRequestException,
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common';
import { FirebaseService } from '../firebase/firebase.service';
import { DocumentProcessingService } from './document-processing.service';
import { UploadDocumentDto } from './dto';
import { Document, DocumentListItem } from '../common/interfaces';
import * as admin from 'firebase-admin';
import { FIRESTORE_COLLECTIONS } from '../common/constants';
import { LoggerService } from '../common/services/logger.service';
import { FlowTrackerService } from '../common/services/flow-tracker.service';
import { LogMethod } from '../common/decorators';

@Injectable()
export class DocumentsService {
  private readonly logger: LoggerService;
  private readonly flowTracker: FlowTrackerService;

  constructor(
    private documentProcessingService: DocumentProcessingService,
    private firebaseService: FirebaseService,
  ) {
    this.logger = LoggerService.getInstance();
    this.flowTracker = FlowTrackerService.getInstance();
  }

  /**
   * Dosyadan metin √ßƒ±karma i≈ülemi
   * @param file Dosya
   * @returns √áƒ±karƒ±lan metin
   */
  async extractTextFromFile(file: Express.Multer.File): Promise<string> {
    this.logger.debug(
      'üîπ Dosyadan metin √ßƒ±karƒ±lƒ±yor',
      'DocumentsService.extractTextFromFile',
      __filename,
    );

    try {
      // DocumentProcessingService'i kullanarak metin √ßƒ±kartma
      const extractedText = await this.documentProcessingService.extractText(
        file.buffer,
        file.mimetype,
      );

      // √áƒ±karƒ±lan metni normalize et
      const normalizedText =
        this.documentProcessingService.normalizeText(extractedText);

      this.logger.debug(
        `Metin √ßƒ±karma ba≈üarƒ±lƒ± (${normalizedText.length} karakter)`,
        'DocumentsService.extractTextFromFile',
        __filename,
        undefined,
        {
          fileName: file.originalname,
          fileType: file.mimetype,
          extractedLength: normalizedText.length,
        },
      );

      return normalizedText;
    } catch (error) {
      this.logger.error(
        `Metin √ßƒ±karma hatasƒ±: ${error.message}`,
        'DocumentsService.extractTextFromFile',
        __filename,
      );
      throw new BadRequestException(
        `Belgeden metin √ßƒ±karƒ±lƒ±rken hata olu≈ütu: ${error.message}`,
      );
    }
  }

  /**
   * Upload a document to storage and process its text
   */
  @LogMethod({ trackParams: true })
  async uploadDocument(
    file: Express.Multer.File,
    userId: string,
    courseId?: string,
    fileName?: string,
  ): Promise<any> {
    this.logger.debug(
      'üîπ Dok√ºman y√ºkleniyor',
      'DocumentsService.uploadDocument',
      __filename,
    );

    try {
      // Benzersiz dosya adƒ± olu≈ütur
      const timestamp = Date.now();
      const originalName = file.originalname;
      const fileExtension = originalName.split('.').pop();
      const uniqueFileName = fileName
        ? `${fileName}.${fileExtension}`
        : `${timestamp}_${originalName}`;

      // Firebase'e dosyayƒ± y√ºkle
      let fileUrl = '';
      let storagePath = `documents/${userId}/general/${uniqueFileName}`;

      try {
        // Firebase Storage'a y√ºklemeyi dene
        fileUrl = await this.firebaseService.uploadFile(
          file.buffer,
          storagePath,
          file.mimetype,
        );

        console.log(`üì§ Dosya Firebase Storage'a y√ºklendi: ${fileUrl}`);
      } catch (storageError) {
        // Firebase Storage hatasƒ± durumunda loglama yap
        this.logger.error(
          `Firebase Storage y√ºkleme hatasƒ±: ${storageError.message}`,
          'DocumentsService.uploadDocument',
          __filename,
        );

        // Hata durumunda ge√ßici bir URL olu≈ütur (ger√ßek projede farklƒ± bir √ß√∂z√ºm gerekebilir)
        fileUrl = `http://localhost:3001/api/documents/temp/${uniqueFileName}`;
        console.log(
          `‚ö†Ô∏è Firebase Storage hatasƒ±. Ge√ßici URL kullanƒ±lƒ±yor: ${fileUrl}`,
        );
      }

      // Metin √ßƒ±karma i≈ülemini ba≈ülat
      const extractedText = await this.extractTextFromFile(file);

      this.logger.debug(
        `üìÑ Dosyadan metin √ßƒ±karma tamamlandƒ± (${extractedText?.length || 0} karakter). ƒ∞√ßerik (ilk 100kr): ${extractedText?.substring(0, 100)}`,
        'DocumentsService.uploadDocument',
        __filename,
        undefined,
        {
          documentId: 'N/A',
          userId,
          fileName: originalName,
          extractedLength: extractedText?.length || 0,
        },
      );

      // Yeni dok√ºman olu≈ütur
      const newDocument = {
        fileName: originalName,
        fileUrl: fileUrl,
        storagePath: storagePath,
        storageUrl: fileUrl,
        fileType: file.mimetype,
        fileSize: file.size,
        extractedText: extractedText,
        userId: userId,
        courseId: courseId || null,
      };

      // Firestore'a kaydetmeden √∂nce logla
      this.logger.debug(
        `üíæ D√∂k√ºman Firestore'a kaydedilmeden √ñNCE: ${originalName}`,
        'DocumentsService.uploadDocument',
        __filename,
        undefined,
        { documentDetails: newDocument },
      );

      // Dokuman koleksiyonuna ekle
      const document = await this.firebaseService.create(
        'documents',
        newDocument,
      );

      console.log(`‚úÖ D√∂k√ºman ba≈üarƒ±yla kaydedildi. ID: ${document.id}`);
      return document;
    } catch (error) {
      this.logger.error(
        `D√∂k√ºman y√ºkleme hatasƒ±: ${error.message}`,
        'DocumentsService.uploadDocument',
        __filename,
      );

      console.error(`‚ùå D√∂k√ºman y√ºkleme hatasƒ±: ${error.message}`);
      throw error;
    }
  }

  /**
   * List all documents for a user, optionally filtered by course
   */
  @LogMethod({ trackParams: true })
  async findAll(
    userId: string,
    courseId?: string,
  ): Promise<DocumentListItem[]> {
    try {
      this.flowTracker.trackStep(
        courseId
          ? `${courseId} kursu i√ßin dok√ºmanlar getiriliyor`
          : 'T√ºm dok√ºmanlar getiriliyor',
        'DocumentsService',
      );

      // Filtre ko≈üullarƒ±nƒ± olu≈ütur
      const wheres = [
        {
          field: 'userId',
          operator: '==' as admin.firestore.WhereFilterOp,
          value: userId,
        },
      ];

      if (courseId) {
        // Ders sahipliƒüi kontrol√º
        const course = await this.firebaseService.findOne<{ userId: string }>(
          FIRESTORE_COLLECTIONS.COURSES,
          'id',
          '==',
          courseId,
        );

        if (!course) {
          throw new NotFoundException('Ders bulunamadƒ±');
        }

        wheres.push({
          field: 'courseId',
          operator: '==' as admin.firestore.WhereFilterOp,
          value: courseId,
        });
      }

      // Belgeleri getir
      const docs = await this.firebaseService.findMany<Document>(
        FIRESTORE_COLLECTIONS.DOCUMENTS,
        wheres,
        { field: 'createdAt', direction: 'desc' },
      );

      this.logger.info(
        'Dok√ºmanlar ba≈üarƒ±yla getirildi',
        'DocumentsService.findAll',
        __filename,
        undefined,
        { userId, courseId },
      );

      return docs.map((doc) => ({
        id: doc.id,
        fileName: doc.fileName,
        storagePath: doc.storagePath,
        storageUrl: doc.storageUrl,
        fileType: doc.fileType,
        fileSize: doc.fileSize,
        courseId: doc.courseId,
        createdAt: doc.createdAt
          ? new Date(doc.createdAt).toISOString()
          : doc.createdAt,
      }));
    } catch (error) {
      this.logger.logError(error, 'DocumentsService.findAll', {
        userId,
        courseId,
      });
      throw error;
    }
  }

  /**
   * Get a single document by ID
   */
  @LogMethod({ trackParams: true })
  async findOne(id: string, userId: string): Promise<Document> {
    try {
      this.flowTracker.trackStep(
        `${id} ID'li dok√ºman getiriliyor`,
        'DocumentsService',
      );

      const document = await this.firebaseService.findById<Document>(
        FIRESTORE_COLLECTIONS.DOCUMENTS,
        id,
      );

      if (!document) {
        throw new NotFoundException('Belge bulunamadƒ±');
      }

      if (document.userId !== userId) {
        throw new NotFoundException('Belge bulunamadƒ±');
      }

      this.logger.info(
        'Dok√ºman ba≈üarƒ±yla getirildi',
        'DocumentsService.findOne',
        __filename,
        undefined,
        { documentId: id, userId },
      );

      return {
        ...document,
        createdAt: document.createdAt
          ? new Date(document.createdAt).toISOString()
          : document.createdAt,
      };
    } catch (error) {
      this.logger.logError(error, 'DocumentsService.findOne', {
        documentId: id,
        userId,
      });
      throw error;
    }
  }

  /**
   * Get document text for a document
   */
  @LogMethod({ trackParams: true })
  async getDocumentText(id: string, userId: string): Promise<{ text: string }> {
    try {
      this.logger.debug(
        `Belge metni isteniyor. Belge ID: ${id}, Kullanƒ±cƒ± ID: ${userId}`,
        'DocumentsService.getDocumentText',
        __filename,
        undefined,
        {
          documentId: id,
          userId,
        },
      );

      // Belgeyi getir
      const document = await this.firebaseService.findById<Document>(
        FIRESTORE_COLLECTIONS.DOCUMENTS,
        id,
      );

      this.logger.debug(
        `getDocumentText: firebaseService.findById √ßaƒürƒ±sƒ± sonrasƒ±. Belge ID: ${id}. D√∂nen 'document' objesinin varlƒ±ƒüƒ±: ${!!document}. ƒ∞√ßerik (ilk 100 byte): ${document ? JSON.stringify(document).substring(0, 100) : 'NULL'}`,
        'DocumentsService.getDocumentText',
        __filename,
        undefined, // flow.traceId yerine undefined kullandƒ±m
        { documentId: id, userId, documentExists: !!document },
      );

      if (!document) {
        // Hata durumunu debug seviyesinde logla, ancak √∂nemli bir hata olduƒüu i√ßin ayrƒ±ca error logu da d√º≈ü√ºlebilir.
        this.logger.debug(
          `Belge bulunamadƒ± (ID: ${id}, Kullanƒ±cƒ±: ${userId})`,
          'DocumentsService.getDocumentText',
          __filename,
          undefined,
          {
            documentId: id,
            userId,
            additionalInfo: 'Belge veritabanƒ±nda bulunamadƒ±',
          },
        );

        throw new NotFoundException('Belge bulunamadƒ±');
      }

      if (!document.extractedText || document.extractedText.trim() === '') {
        this.logger.debug(
          `Belge bulundu (ID: ${id}) ancak 'extractedText' alanƒ± bo≈ü veya tanƒ±msƒ±z.`,
          'DocumentsService.getDocumentText',
          __filename,
          undefined,
          {
            documentId: id,
            userId,
            hasExtractedText: !!document.extractedText,
            textLength: document.extractedText?.length || 0,
          },
        );

        // Daha a√ßƒ±klayƒ±cƒ± bir hata mesajƒ± fƒ±rlat
        throw new BadRequestException(
          `'extractedText' alanƒ± bo≈ü veya tanƒ±msƒ±z. Belge ID: ${id}`,
        );
      }

      this.logger.debug(
        `Belge metni ba≈üarƒ±yla alƒ±ndƒ± (ID: ${id}, Uzunluk: ${document.extractedText.length})`,
        'DocumentsService.getDocumentText',
        __filename,
        undefined,
        {
          documentId: id,
          userId,
          textLength: document.extractedText.length,
        },
      );
      return { text: document.extractedText };
    } catch (error) {
      // Hata zaten NotFoundException veya BadRequestException ise tekrar sarmalama
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }

      // Diƒüer hatalar i√ßin genel bir hata logu
      this.logger.error(
        `Belge metni alƒ±nƒ±rken hata olu≈ütu: ${error.message}`,
        'DocumentsService.getDocumentText',
        __filename,
        undefined,
      );
      throw new InternalServerErrorException(
        'Belge metni alƒ±nƒ±rken bir hata olu≈ütu.',
      );
    }
  }

  /**
   * Remove a document
   */
  @LogMethod({ trackParams: true })
  async remove(id: string, userId: string): Promise<Document> {
    try {
      this.flowTracker.trackStep(
        `${id} ID'li dok√ºman siliniyor`,
        'DocumentsService',
      );

      // √ñnce belge bilgisi alƒ±nƒ±r
      const document = await this.firebaseService.findById<Document>(
        FIRESTORE_COLLECTIONS.DOCUMENTS,
        id,
      );

      if (!document) {
        throw new NotFoundException('Belge bulunamadƒ±');
      }

      if (document.userId !== userId) {
        throw new NotFoundException('Belge bulunamadƒ±');
      }

      // Depodan silme i≈ülemi
      try {
        await this.firebaseService.deleteFile(document.storagePath);
      } catch (error) {
        this.logger.error(`Dosya silme hatasƒ±: ${error.message}`, error.stack);
        // Dosya silinmese bile veritabanƒ± kaydƒ±nƒ± silmeye devam ediyoruz
      }

      // Veritabanƒ±ndan silme i≈ülemi
      await this.firebaseService.delete(FIRESTORE_COLLECTIONS.DOCUMENTS, id);

      this.logger.info(
        'Dok√ºman ba≈üarƒ±yla silindi',
        'DocumentsService.remove',
        __filename,
        undefined,
        { documentId: id, userId },
      );

      return document;
    } catch (error) {
      this.logger.logError(error, 'DocumentsService.remove', {
        documentId: id,
        userId,
      });
      throw error;
    }
  }
}
